import numpy as np

correct_outs = {
    'affine_forward': 
        np.array([
        [-0.34448963, -0.15630714,  0.03187535],
        [-0.18626697,  0.0119934 ,  0.21025377],
        [-0.0280443 ,  0.18029394,  0.38863218],
        [ 0.13017836,  0.34859447,  0.56701059],
        [ 0.28840102,  0.51689501,  0.74538901],
        [ 0.44662368,  0.68519555,  0.92376742],
        [ 0.60484634,  0.85349608,  1.10214583],
        [ 0.763069  ,  1.02179662,  1.28052425],
        [ 0.92129166,  1.19009716,  1.45890266],
        [ 1.07951432,  1.35839769,  1.63728107]]),

    'ExponentialLinearUnit_forward':
        np.array([[ 0.00000000e+00,  2.00000000e+00,  6.00000000e+00,  8.00000000e+00],
       [-8.64664717e-01,  4.00000000e+00,  8.00000000e+00,  3.54600000e+03],
       [-1.00000000e+00,  2.60000000e+00,  8.00000000e-01, -1.81269247e-01]]),

    
    'ReLU_forward':
        np.array([
            [0.000, 1.000, 3.000, 4.000],
            [0.000, 2.000, 4.000, 1773],
            [0.000, 1.300, 0.4, 0]]),

'LeakyReLU_forward':
        np.array([[   0. , 2. , 6. , 8.   ],[ -0.02 ,  4. , 8. , 3546.   ],[ -35.46 , 2.6 , 0.8 , -0.002]]),

    'ReLU_forward2':
        np.array([
            [0.000, 2.000, 6.000, 8.000],
            [0.000, 4.000, 8.000, 3546],
            [0.000, 2.600, 0.8, 0]]),
    
    'Softplus_forward':
        np.array([
            [0.69314718,  1.31326169,  3.04858735,  4.01814993],
            [0.31326169,  0.12692801,  0.04858735,  0.01814993],
            [10.0000454 ,  5.00671535,  6.00247569,  7.00091147]]),

    'Sigmoid_forward':
        np.array([[5.00000000e-01, 8.80797078e-01, 9.97527377e-01, 9.99664650e-01],
            [1.19202922e-01, 1.79862100e-02, 2.47262316e-03, 3.35350130e-04],
            [9.99999998e-01, 9.99954602e-01, 9.99993856e-01, 9.99999168e-01]]),

    'Swish_forward':
        np.array([[ 0.00000000e+00,  1.76159416e+00,  5.98516426e+00,  7.99731720e+00],
            [-2.38405844e-01, -7.19448398e-02, -1.48357389e-02, -2.68280104e-03],
            [ 2.00000000e+01,  9.99954602e+00,  1.19999263e+01,  1.39999884e+01]]),

    'SGD_weights_0':
        np.array([[ 0.80820516,  0.44935409],
                [-0.46576358,  0.31120224],
                [ 0.84643652,  0.33262473],
                [ 0.4753607 ,  0.61578243],
                [ 0.17191167, -0.30614227],
                [ 0.27959828,  0.01355021],
                [ 0.47115301,  0.72900182],
                [ 0.2671234 ,  0.92012222],
                [ 0.25725081,  0.96928999],
                [ 0.98271772,  0.50181485]]),
    
    'SGD_biases_0':
        np.array([-0.07878265, -0.07357376]),

    'SGD_weights_1':
        np.array([[0.42620505, 0.35822559, 0.80335453],
                [0.01046392, 1.09098992, 0.95917019]]),
    
    'SGD_biases_1':
        np.array([-0.11529386, -0.00237832,  0.11767218]),    


    'RMSprop_weights_0':
        np.array([[-2.29715828, -2.6285197 ],
        [-2.97336674, -2.23975148],
        [ 4.00468689,  3.45793876],
        [ 3.5897939 ,  3.69178751],
        [-2.60215967, -3.07764008],
        [-2.76920439, -3.0089266 ],
        [-2.63485857, -2.40068978],
        [ 3.37863838,  4.02114756],
        [ 3.29797162,  3.95203337],
        [ 4.08425355,  3.66104838]]),
    
    'RMSprop_biases_0':
        np.array([-3.16227639, -3.1622763 ]),

    'RMSprop_weights_1':
        np.array([[-2.29715981, -2.62852031,  3.35118827],
        [-2.23975154,  4.00471147,  3.45794131]]),
    
    'RMSprop_biases_1':
        np.array([-3.16227679, -3.16223561,  3.16227681]),

    'SGDWithMomentum_weights_0':
        np.array([[ 0.83666139,  0.49155543],
        [-0.13842641,  0.61686413],
        [ 0.84443537,  0.31414427],
        [ 0.45143952,  0.57264672],
        [ 0.3660147 , -0.11075247],
        [ 0.33633533,  0.08345028],
        [ 0.49928516,  0.74529332],
        [ 0.24174304,  0.88949688],
        [ 0.1964728 ,  0.87952313],
        [ 0.95234763,  0.50030939]]),
    
    'SGDWithMomentum_biases_0':
        np. array([-0.03939133, -0.03678688]),

    'SGDWithMomentum_weights_1':
        np.array([[0.64566133, 0.44599119, 0.49613265],
        [0.46649497, 0.96671206, 0.627417  ]]),
    
    'SGDWithMomentum_biases_1':
        np. array([-0.05764693, -0.00118916,  0.05883609]),

    'SGDWithMomentum_reg_weights_0':
        np.array([[ 0.75014963,  0.43817976],
        [-0.15731748,  0.52461153],
        [ 0.76019195,  0.28457789],
        [ 0.40868769,  0.51969562],
        [ 0.31000293, -0.1192162 ],
        [ 0.2970281 ,  0.06811524],
        [ 0.44654343,  0.66913484],
        [ 0.22010678,  0.80360972],
        [ 0.18290332,  0.8005475 ],
        [ 0.86014987,  0.450429  ]]),
    
    'SGDWithMomentum_reg_biases_0':
        np.array([-0.03939133, -0.03678688]),

    'SGDWithMomentum_reg_weights_1':
        np.array([[0.55914957, 0.39261551, 0.47724157],
        [0.37424236, 0.88246864, 0.59785062]]),
    
    'SGDWithMomentum_reg_biases_1':
        np.array([-0.05764693, -0.00118916,  0.05883609]), 
}



def rel_error(x, y):
    if type(y) == str:
        y = correct_outs[y]
    return np.max(np.abs(x - y) / (np.maximum(1e-8, np.abs(x) + np.abs(y))))


def grad_check(f, x, df=None, h=1e-5):
    grad = np.zeros(x.shape)
    it = np.nditer(x, flags=['multi_index'])
    while not it.finished:
        ix = it.multi_index

        oldval = x[ix]
        x[ix] = oldval + h
        plus = f(x).copy()
        x[ix] = oldval - h
        minus = f(x).copy()
        x[ix] = oldval
        if df is not None:
            grad[ix] = np.sum((plus - minus) * df) / (2 * h)
        else:
            grad[ix] = (plus - minus) / (2 * h)
        it.iternext()
    return grad

